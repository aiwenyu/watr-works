package edu.umass.cs.iesl.watr
package watrcolors
package server


import corpora._
import textreflow._
import geometry._

import com.sksamuel.scrimage
import scrimage._
import scrimage.{canvas => SC}
import watrmarks._

class LabelingServer(
  reflowDB: TextReflowDB,
  corpus: Corpus
) {


  def rescale(bbox: LTBounds, page1: LTBounds, page2: LTBounds): LTBounds = {
    val LTBounds(l, t, w, h) = bbox
    val scaleX = page2.width/page1.width
    val scaleY = page2.height/page1.height
    val l2 = l * scaleX
    val t2 = t * scaleY
    val w2 = w * scaleX
    val h2 = h * scaleY
    val res = LTBounds(l2, t2, w2, h2)
    res
  }



  def ltBoundsToDrawables(bbox: LTBounds, pageGeometry: PageGeometry, imageGeometry: LTBounds): List[SC.Drawable] =  {
    val LTBounds(rl, rt, rw, rh) = rescale(bbox, pageGeometry.bounds, imageGeometry)
    val ctx = SC.Context.painter(Color(10, 10, 220, 40))
    val r = SC.Rect(rl.toInt, rt.toInt, rw.toInt, rh.toInt, ctx)
    val ctx2 = SC.Context.painter(Color(10, 10, 0, 150))
    val underline = SC.Line(x0=r.x, y0=r.y+r.height, r.x+r.width, r.y+r.height, ctx2)
    val leftline = SC.Line(x0=r.x, y0=r.y, r.x, r.y+r.height, ctx2)
    List[SC.Drawable](r.fill, underline, leftline)
  }

  def embossTargetRegion(targetRegion: TargetRegion, labels: Seq[Label]): Unit = {
    val docId = targetRegion.docId
    val pageId = targetRegion.pageId

    val (pageImage, pageGeometry) = reflowDB.getPageImageAndGeometry(docId, pageId)

    val (pageW, pageH) = pageImage.dimensions
    val imageGeometry = LTBounds(0, 0, pageW.toDouble, pageH.toDouble)

    val maskCanvas = new SC.Canvas(
      Image.filled(pageW.toInt, pageH.toInt, Color.Transparent)
    )

    val hardcodeLabel = LB.VisualLine
    // select all zones w/label on given page
    val zones = reflowDB.selectZones(docId, pageId, hardcodeLabel)
    val embossings = for {
      zone <- zones
      region <- zone.regions
    } yield {
      ltBoundsToDrawables(region.bbox, pageGeometry, imageGeometry)
    }

    val embossedCanvas = maskCanvas.draw(embossings.flatten)
    val overlay = pageImage.overlay(embossedCanvas.image, 0, 0)

    val imageClipRegion @ LTBounds(clipL, clipT, clipW, clipH) =
      rescale(targetRegion.bbox, pageGeometry.bounds, imageGeometry)

    // println(s"embossTargetRegion: clipping image to ${imageClipRegion} w/geom ${imageGeometry}")

    val clippedPageImage = overlay.subimage(
      clipL.toInt,
      clipT.toInt,
      clipL.toInt + clipW.toInt,
      clipT.toInt + clipH.toInt
    )

    reflowDB.overwriteTargetRegionImage(targetRegion, clippedPageImage)
  }

  // implicit class Labeler_RicherCorpusEntry(val theCorpusEntry: CorpusEntry) extends {
  //   def text(): Seq[TextReflow] = {
  //     ???
  //   }
  // }
  import utils.{CompassDirection => CDir}
  case class LwAccum(
    regions: List[(TargetRegion, LTBounds)]
  )

  def renderLabelWidget(lwidget: LabelWidget): LwAccum = {

    def visit(t: LabelWidgetF[(LabelWidget, LwAccum)]): Future[LwAccum] = t match {
      case Target(tr, emboss, sels)  =>
        makeImageForTargetRegion(tr)
          .map({img =>
            val trPositionVec = tr.bbox.toPoint(CDir.NW)

            val adjustedSelects = sels.map({preselect:LTBounds =>
              val selectPositionVec = preselect.toPoint(CDir.NW)
              val adjustedPos = selectPositionVec - trPositionVec
              preselect.moveTo(adjustedPos.x, adjustedPos.y)
            })

            LwAccum(
              img,
              List(
                (tr, tr.bbox.moveToOrigin)
              )
            )
          })


      case Col(attrs) =>
        val lls: Future[List[LwRenderingAttrs]] = attrs.map(_._2).sequenceU

        lls.map(vjoinAttrs(_))

      case Panel((content, attr))  =>
        attr.map({ fobj =>
          addBorder(4.0, fobj)
        })

      case MouseOverlay((bkplane, fattr)) =>
        // createShape(tr.bounds, "black", "yellow", 1f)
        fattr.map({ attr =>
          // addBorder(4.0, fobj)
        })

        ???

      case _ => sys.error("echoLabeler: TODO")
    }

    lwidget
      .cata(attributePara(visit))
      .toPair._1.map(_.fobj)
  }
}
